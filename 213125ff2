if game.PlaceId ~= 8206123457 and game.PlaceId == 8204899140 then
	-->> Services >>
	local Players = cloneref(game:GetService("Players"))
	local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))

	-->> Variables >>
	local LocalPlayer = Players.LocalPlayer

	-->> Utilities
	local AC_STRING = nil
	local HandshakeArguments = nil
	local HandshakeRemote = ReplicatedStorage:WaitForChild("Remotes"):FindFirstChild("CharacterSoundEvent")
	local LastCheck = nil
	local LastCheckTwo = nil

	-->> Functions >>
	local ReplicateHandshake = function()
		if AC_STRING ~= nil and HandshakeArguments then
			return HandshakeRemote:fireServer(AC_STRING, HandshakeArguments, nil)
		end
	end

	-->> Hooks >>
	local OldInfo
	OldInfo = hookfunction(debug.info, function(Level, Stuff)
		if Level == 2 and Stuff == "s" then
			return "LocalScript"
		end

		return OldInfo(Level, Stuff)
	end)

	local OldCheck
	OldCheck = hookfunction(getrawmetatable(game).__namecall, function(Self, ...)
		local Method = getnamecallmethod()
		local Args = {...}

		if not checkcaller() and Method == "fireServer" and Self == HandshakeRemote then
			if Args[1] and string.find(Args[1], "AC") then
				if Args[2] == "error" then
					return
				end

				if Args[2] == nil then
					return
				end

				local Table = getrawmetatable(Args[2]).__tostring
				LastCheckTwo = tick()

				AC_STRING = Args[1]

				if type(Args[2]) == "table" then
					if not HandshakeArguments then
						HandshakeArguments = Args[2]
					else
						return coroutine.yield()
					end
				end
			end
		end

		return OldCheck(Self, ...)
	end)

	for Index, Function in next, getgc() do
		if type(Function) == "function" and getinfo(Function).source:find("ReplicatedFirst.LocalScript") then
			hookfunction(Function, function()

			end)
		end
	end

	task.wait(3)

	-->> Grab Shuffle Function >>
	for Index, Function in next, getgc() do
		if type(Function) == "function" then
			if getinfo(Function).source:find("PlayerModule.LocalScript") then
				if getinfo(Function).numparams == 7 then
					local Shuffle
					Shuffle = hookfunction(Function, function(...)
						local Args = {...}

						if Args[2] ~= 760 and Args[3] ~= 760 and Args[4] ~= 771 and Args[5] ~= 665 and Args[6] ~= 898 or Args[2] ~= 655 and Args[3] ~= 775 and Args[4] ~= 724 and Args[5] ~= 633 and Args[6] ~= 891 and Args[2] ~= 660 and Args[3] ~= 759 and Args[4] ~= 751 and Args[5] ~= 863 and Args[6] ~= 771 then
							return coroutine.yield()
						end
				
						LastCheck = tick()
				
						return Shuffle(...)
					end)
				end
			end
		end
	end

	task.spawn(function()
		while task.wait(0.4) do
			if LastCheck ~= nil and (LastCheck - tick()) >= 10 then
				warn("Bypass timed out.")
				task.wait(20)
				LocalPlayer:Kick("")
				game.CoreGui.RobloxPromptGui.promptOverlay.ErrorPrompt.TitleFrame.ErrorTitle.Text = "Bypass Error."
				game.CoreGui.RobloxPromptGui.promptOverlay.ErrorPrompt.MessageArea.ErrorFrame.ErrorMessage.Text = "Bypass timed out."
				return
			end

			if LastCheckTwo ~= nil and (LastCheckTwo - tick()) >= 10 then
				warn("Bypass timed out.")
				task.wait(20)
				LocalPlayer:Kick("")
				game.CoreGui.RobloxPromptGui.promptOverlay.ErrorPrompt.TitleFrame.ErrorTitle.Text = "Bypass Error."
				game.CoreGui.RobloxPromptGui.promptOverlay.ErrorPrompt.MessageArea.ErrorFrame.ErrorMessage.Text = "Bypass timed out."
				return
			end
		end
	end)

	task.spawn(function()
		while task.wait(0.4) do
			if AC_STRING and HandshakeArguments then
				HandshakeRemote:fireServer(AC_STRING, HandshakeArguments, nil)
			end
		end
	end)
end

task.wait()

print("Bypass done, Saturn Loading...")















task.wait()

 
print('SaturnHub Loaded!')


--walkspeed
--key

if not LPH_OBFUSCATED then
	LPH_JIT_MAX = function(...) return(...) end;
	LPH_NO_VIRTUALIZE = function(...) return(...) end;
end

local utility = {}
local UIS = game:GetService("UserInputService");
local RS = game:GetService("RunService");
local TS = game:GetService("TweenService");
local mouse = game:GetService('Players').LocalPlayer:GetMouse()

local Library = {}
local mainKeybind = "LeftControl"
local canDrag = true

function utility:ToRGB(color)  
	return color.R*255,color.G*255,color.B*255
end

local function CreateDrag(gui)
	local dragging
	local dragInput
	local dragStart
	local startPos

	local function update(input)
		local delta = input.Position - dragStart
		TS:Create(gui, TweenInfo.new(0.16, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)}):Play();
	end

	local lastEnd = 0
	local lastMoved = 0
	local con
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if not canDrag then return end
			dragging = true
			dragStart = input.Position
			startPos = gui.Position

		end
	end)

	UIS.InputEnded:Connect(function(input)

		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = false
		end
	end)


	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
			lastMoved = os.clock()
		end
	end)

	UIS.InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			update(input)
		end
	end)
end

local tweenInfo = TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
local tweenInfo2 = TweenInfo.new(.5, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
function Library:tween(object, goal, callback)
	local tween = TS:Create(object, tweenInfo, goal)
	tween.Completed:Connect(callback or function() end)
	tween:Play()
end

function Library:tween2(object, goal, callback)
	local tween = TS:Create(object, tweenInfo2, goal)
	tween.Completed:Connect(callback or function() end)
	tween:Play()
end

local ScreenGui = Instance.new('ScreenGui', gethui())

function Library:CreateWindow(options)
	local GUI = {
		CurrentTab = nil
	}
	

	local Main = Instance.new('Frame', ScreenGui)
	local Title = Instance.new('TextLabel', Main)
	local Divider = Instance.new('Frame', Main)
	local TabBar = Instance.new('ScrollingFrame', Main)
	local TabLayout = Instance.new('UIListLayout', TabBar)
	local TabBarPad = Instance.new('UIPadding', TabBar)
	local MainCorner = Instance.new('UICorner', Main)
	local MainGradient = Instance.new('UIGradient', Main)
	local Divider2 = Instance.new('Frame', Main)
	
	ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	Main.Name = "Main"
	Main.Position = UDim2.new(0.271,0,0.2845,0)
	Main.Size = UDim2.new(0,710,0,405)
	Main.BackgroundColor3 = Color3.new(1,1,1)
	Main.BorderSizePixel = 0
	Main.BorderColor3 = Color3.new(0,0,0)
	Main.ZIndex = 100
	Title.Name = "Title"
	Title.Position = UDim2.new(0.0254,0,0,0)
	Title.Size = UDim2.new(0,143,0,50)
	Title.BackgroundColor3 = Color3.new(1,1,1)
	Title.BackgroundTransparency = 1
	Title.BorderSizePixel = 0
	Title.BorderColor3 = Color3.new(0,0,0)
	Title.Text = options.Title
	Title.TextColor3 = Color3.new(0.7843,0.7843,0.7843)
	Title.Font = Enum.Font.Gotham
	Title.TextSize = 23
	Title.ZIndex = 101
	Title.TextXAlignment = Enum.TextXAlignment.Left
	Divider.Name = "Divider"
	Divider.Position = UDim2.new(0,0,0.121,0)
	Divider.Size = UDim2.new(0,710,0,1)
	Divider.BackgroundColor3 = Color3.new(0.7843,0.7843,0.7843)
	Divider.BorderSizePixel = 0
	Divider.BorderColor3 = Color3.new(0,0,0)
	Divider.ZIndex = 102
	TabBar.Name = "TabBar"
	TabBar.Position = UDim2.new(0,0,0.1235,0)
	TabBar.Size = UDim2.new(0,161,0,355)
	TabBar.BackgroundColor3 = Color3.new(1,1,1)
	TabBar.BackgroundTransparency = 1
	TabBar.BorderSizePixel = 0
	TabBar.BorderColor3 = Color3.new(0,0,0)
	TabBar.ZIndex = 103
	TabBar.ScrollingEnabled = false
	TabBar.ScrollBarThickness = 0
	TabBar.ScrollBarImageColor3 = Color3.new(0,0,0)
	TabLayout.Name = "TabLayout"
	TabLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	TabLayout.SortOrder = Enum.SortOrder.LayoutOrder
	TabBarPad.Name = "TabBarPad"
	TabBarPad.PaddingTop = UDim.new(0,5)
	Divider2.Name = "Divider2"
	Divider2.Position = UDim2.new(0.2246,0,0.121,0)
	Divider2.Size = UDim2.new(0,1,0,356)
	Divider2.BackgroundColor3 = Color3.new(0.6392,0.6392,0.6392)
	Divider2.BackgroundTransparency = 0.5
	Divider2.BorderSizePixel = 0
	Divider2.BorderColor3 = Color3.new(0,0,0)
	Divider2.ZIndex = 102
	MainCorner.CornerRadius = UDim.new(0,20)
	MainGradient.Name = "MainGradient"
	MainGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.new(0.04313725605607033, 0.019607843831181526, 0.15294118225574493)), ColorSequenceKeypoint.new(1.00,Color3.new(0.5098039507865906, 0.1882352977991104, 0.1568627506494522))}

	local MC = Instance.new('ScreenGui', gethui())
	local MobileCard = Instance.new('ImageButton', MC)
	local CardGradient = Instance.new('UIGradient', MobileCard)
	local CardText = Instance.new('TextLabel', MobileCard)
	local CardCorner = Instance.new('UICorner', MobileCard)

	MC.Name = "MC"
	MC.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	MobileCard.Name = "MobileCard"
	MobileCard.Position = UDim2.new(0.5, -20, 0, 10);
	MobileCard.Size = UDim2.new(0,40,0,40)
	MobileCard.BackgroundColor3 = Color3.new(1,1,1)
	MobileCard.BorderSizePixel = 0
	MobileCard.BorderColor3 = Color3.new(0,0,0)
	MobileCard.AutoButtonColor = false
	CardGradient.Name = "CardGradient"
	CardGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.new(0.04313725605607033, 0.019607843831181526, 0.15294118225574493)), ColorSequenceKeypoint.new(1.00,Color3.new(0.5098039507865906, 0.1882352977991104, 0.1568627506494522))}
	CardGradient.Rotation = -84
	CardText.Name = "CardText"
	CardText.Size = UDim2.new(0,40,0,40)
	CardText.BackgroundColor3 = Color3.new(1,1,1)
	CardText.BackgroundTransparency = 1
	CardText.BorderSizePixel = 0
	CardText.BorderColor3 = Color3.new(0,0,0)
	CardText.Text = "S"
	CardText.TextColor3 = Color3.new(0.7843,0.7843,0.7843)
	CardText.Font = Enum.Font.Gotham
	CardText.TextSize = 23
	CardText.ZIndex = 101

	MobileCard.MouseButton1Click:Connect(function()
		ScreenGui.Enabled = not ScreenGui.Enabled
	end)
	
	CreateDrag(MobileCard)
	CreateDrag(Main)

	function Library:Toggle()
		ScreenGui.Enabled = not ScreenGui.Enabled
	end

	UIS.InputBegan:Connect(function(key, gp)
		if gp then return end;

		if key.KeyCode == Enum.KeyCode[mainKeybind] then
			Library:Toggle()
		end
	end)

	function GUI:NewTab(options)
		
		local tab = {
			Active = false
		}
		
		local Canvas = Instance.new('ScrollingFrame', Main)
		local UIListLayout = Instance.new('UIListLayout', Canvas)
		local UIPadding = Instance.new('UIPadding', Canvas)
		local SelectedTab = Instance.new('Frame', TabBar)
		local Highlight = Instance.new('Frame', SelectedTab)
		local STCorner = Instance.new('UICorner', SelectedTab)
		local Tab = Instance.new('TextButton', SelectedTab)
		
		SelectedTab.Name = "SelectedTab"
		SelectedTab.Position = UDim2.new(88.03,0,0.6006,0)
		SelectedTab.Size = UDim2.new(0,118,0,34)
		SelectedTab.BackgroundColor3 = Color3.new(0,0,0)
		SelectedTab.BackgroundTransparency = 1
		SelectedTab.BorderSizePixel = 0
		SelectedTab.BorderColor3 = Color3.new(0,0,0)
		SelectedTab.ZIndex = 100
		Highlight.Name = "Highlight"
		Highlight.Position = UDim2.new(0.0508,0,0.2353,0)
		Highlight.Size = UDim2.new(0,2,0,18)
		Highlight.BackgroundColor3 = Color3.new(0.8353,0.8353,0.8353)
		Highlight.BorderSizePixel = 0
		Highlight.Transparency = 1
		Highlight.BorderColor3 = Color3.new(0,0,0)
		Highlight.ZIndex = 101
		STCorner.CornerRadius = UDim.new(0,6)
		Tab.Name = "Tab"
		Tab.Position = UDim2.new(0.0678,0,0,0)
		Tab.Size = UDim2.new(0,109,0,34)
		Tab.BackgroundColor3 = Color3.new(1,1,1)
		Tab.BackgroundTransparency = 1
		Tab.BorderSizePixel = 0
		Tab.BorderColor3 = Color3.new(0,0,0)
		Tab.Text = options.Name
		Tab.TextColor3 = Color3.new(0.5529,0.5529,0.5529)
		Tab.Font = Enum.Font.Gotham
		Tab.TextSize = 14
		Tab.ZIndex = 105
		Tab.AutoButtonColor = false		
		Canvas.Name = "Canvas"
		Canvas.Position = UDim2.new(0.2268,0,0.1235,0)
		Canvas.Size = UDim2.new(0,549,0,355)
		Canvas.BackgroundColor3 = Color3.new(1,1,1)
		Canvas.BackgroundTransparency = 1
		Canvas.BorderSizePixel = 0
		Canvas.BorderColor3 = Color3.new(0,0,0)
		Canvas.ZIndex = 107
		Canvas.Visible = false
		Canvas.AutomaticCanvasSize = Enum.AutomaticSize.Y;
		Canvas.ScrollBarThickness = 0
		Canvas.ScrollBarImageColor3 = Color3.new(0,0,0)
		UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
		UIListLayout.Padding = UDim.new(0,5)
		UIPadding.PaddingTop = UDim.new(0,10)
		
		function tab:Activate()
			if not tab.Active then
				if GUI.CurrentTab ~= nil then
					GUI.CurrentTab:Deactivate()
				end
				tab.Active = true
				Library:tween(Tab, {TextColor3 = Color3.new(1,1,1)})
				Library:tween(SelectedTab, {BackgroundTransparency = 0.5})
				Library:tween(Highlight, {BackgroundTransparency = 0})
				Canvas.Visible = true
				GUI.CurrentTab = tab
			end
		end

		function tab:Deactivate()
			if tab.Active then
				tab.Active = false
				Library:tween(Tab, {TextColor3 =Color3.new(0.5529,0.5529,0.5529)})
				Library:tween(SelectedTab, {BackgroundTransparency = 1})
				Library:tween(Highlight, {BackgroundTransparency = 1})
				Canvas.Visible = false
			end
		end

		Tab.MouseButton1Click:Connect(function()
			tab:Activate()
		end)

		if GUI.CurrentTab == nil then
			tab.Activate()	
		end
		
		
		function tab:NewToggle(options)
			
			local toggle = {
				State = false
			}
			
			local Toggle = Instance.new('ImageButton', Canvas)
			local ToggleTitle = Instance.new('TextLabel', Toggle)
			local CheckBox = Instance.new('Frame', Toggle)
			local CheckBoxCorner = Instance.new('UICorner', CheckBox)
			local CheckMark = Instance.new('ImageButton', CheckBox)
			local ToggleCorner = Instance.new('UICorner', Toggle)
			


			Toggle.Name = "Toggle"
			Toggle.Position = UDim2.new(0.2606,0,0.5185,0)
			Toggle.Size = UDim2.new(0,499,0,34)
			Toggle.BackgroundColor3 = Color3.new(0,0,0)
			Toggle.BackgroundTransparency = 0.5
			Toggle.BorderSizePixel = 0
			Toggle.BorderColor3 = Color3.new(0,0,0)
			Toggle.ZIndex = 108
			Toggle.AutoButtonColor = false		
			ToggleTitle.Name = "ToggleTitle"
			ToggleTitle.Position = UDim2.new(0.0321,0,0,0)
			ToggleTitle.Size = UDim2.new(0,363,0,34)
			ToggleTitle.BackgroundColor3 = Color3.new(1,1,1)
			ToggleTitle.BackgroundTransparency = 1
			ToggleTitle.BorderSizePixel = 0
			ToggleTitle.BorderColor3 = Color3.new(0,0,0)
			ToggleTitle.Text = options.Name
			ToggleTitle.TextColor3 = Color3.new(0.851,0.851,0.851)
			ToggleTitle.Font = Enum.Font.Gotham
			ToggleTitle.TextSize = 14
			ToggleTitle.ZIndex = 109
			ToggleTitle.TextXAlignment = Enum.TextXAlignment.Left
			CheckBox.Name = "CheckBox"
			CheckBox.Position = UDim2.new(0.9359,0,0.1471,0)
			CheckBox.Size = UDim2.new(0,24,0,24)
			CheckBox.BackgroundColor3 = Color3.new(0.0706,0.0706,0.0706)
			CheckBox.BorderSizePixel = 0
			CheckBox.BorderColor3 = Color3.new(0,0,0)
			CheckBox.ZIndex = 107
			CheckBoxCorner.CornerRadius = UDim.new(0,5)
			CheckMark.Name = "CheckMark"
			CheckMark.Position = UDim2.new(0.0464,0,0.0417,0)
			CheckMark.Size = UDim2.new(0,22,0,22)
			CheckMark.BackgroundColor3 = Color3.new(0,0,0)
			CheckMark.BackgroundTransparency = 1
			CheckMark.BorderSizePixel = 0
			CheckMark.BorderColor3 = Color3.new(0,0,0)
			CheckMark.Image = "rbxassetid://6031094667"
			CheckMark.Visible = true
			CheckMark.AutoButtonColor = false
			CheckMark.ZIndex = 107
			ToggleCorner.CornerRadius = UDim.new(0,6)
			
			toggle.State = options.default

			options.callback(toggle.State)

			if toggle.State then
				Library:tween(CheckMark, {ImageTransparency = 0})
			else
				Library:tween(CheckMark, {ImageTransparency = 1})
			end

			function toggle:Toggle(boolean)
				if boolean == nil then
					toggle.State = not toggle.State
				else
					toggle.State = boolean
				end

				if toggle.State then
					print("a")
					Library:tween(CheckMark, {ImageTransparency = 0})
				else
					Library:tween(CheckMark, {ImageTransparency = 1})
				end

				options.callback(toggle.State)
			end

			Toggle.MouseButton1Down:Connect(function()
				toggle:Toggle()
			end)
			
			return toggle
		end
		
		function tab:NewSlider(options)
			local slider = {
				hover = false,
				MouseDown = false,
				connections = {}
			}
			
			local Slider = Instance.new('ImageButton', Canvas)
			local SliderTitle = Instance.new('TextLabel', Slider)
			local SliderBack = Instance.new('Frame', Slider)
			local SliderBackCorner = Instance.new('UICorner', SliderBack)
			local SliderMain = Instance.new('Frame', SliderBack)
			local SliderMainCorner = Instance.new('UICorner', SliderMain)
			local SliderCorner = Instance.new('UICorner', Slider)
			local SliderAmt = Instance.new('TextBox', Slider)
			

			Slider.Name = "Slider"
			Slider.Position = UDim2.new(0.2606,0,0.5185,0)
			Slider.Size = UDim2.new(0,499,0,34)
			Slider.BackgroundColor3 = Color3.new(0,0,0)
			Slider.BackgroundTransparency = 0.5
			Slider.BorderSizePixel = 0
			Slider.BorderColor3 = Color3.new(0,0,0)
			Slider.ZIndex = 108
			Slider.AutoButtonColor = false
			SliderTitle.Name = "SliderTitle"
			SliderTitle.Position = UDim2.new(0.0321,0,0,0)
			SliderTitle.Size = UDim2.new(0,211,0,34)
			SliderTitle.BackgroundColor3 = Color3.new(1,1,1)
			SliderTitle.BackgroundTransparency = 1
			SliderTitle.BorderSizePixel = 0
			SliderTitle.BorderColor3 = Color3.new(0,0,0)
			SliderTitle.Text = options.Name
			SliderTitle.TextColor3 = Color3.new(0.851,0.851,0.851)
			SliderTitle.Font = Enum.Font.Gotham
			SliderTitle.TextSize = 14
			SliderTitle.ZIndex = 109
			SliderTitle.TextXAlignment = Enum.TextXAlignment.Left
			SliderBack.Name = "SliderBack"
			SliderBack.Position = UDim2.new(0.5251,0,0.4118,0)
			SliderBack.Size = UDim2.new(0,229,0,6)
			SliderBack.BackgroundColor3 = Color3.new(0.0706,0.0706,0.0706)
			SliderBack.BorderSizePixel = 0
			SliderBack.BorderColor3 = Color3.new(0,0,0)
			SliderBack.ZIndex = 109
			SliderBackCorner.CornerRadius = UDim.new(0,5)
			SliderMain.Name = "SliderMain"
			SliderMain.Position = UDim2.new(-0,0,0,0)
			SliderMain.Size = UDim2.new(0,118,0,6)
			SliderMain.BackgroundColor3 = Color3.new(1,1,1)
			SliderMain.BorderSizePixel = 0
			SliderMain.BorderColor3 = Color3.new(0,0,0)
			SliderMain.ZIndex = 109
			SliderMainCorner.CornerRadius = UDim.new(0,5)
			SliderCorner.CornerRadius = UDim.new(0,6)
			SliderAmt.Name = "SliderAmt"
			SliderAmt.Position = UDim2.new(0.4569,0,0,0)
			SliderAmt.Size = UDim2.new(0,34,0,34)
			SliderAmt.BackgroundColor3 = Color3.new(1,1,1)
			SliderAmt.BackgroundTransparency = 1
			SliderAmt.BorderSizePixel = 0
			SliderAmt.BorderColor3 = Color3.new(0,0,0)
			SliderAmt.Text = "33"
			SliderAmt.TextColor3 = Color3.new(0.851,0.851,0.851)
			SliderAmt.Font = Enum.Font.Gotham
			SliderAmt.TextSize = 11
			SliderAmt.ZIndex = 109
			

			function slider:SetValue(v)
				if v == nil then
					local percentage = math.clamp((mouse.X - SliderBack.AbsolutePosition.X) / (SliderBack.AbsoluteSize.X), 0, 1)
					local value = ((options.max - options.min) * percentage) + options.min
					if value % 1 == 0 then
						SliderAmt.Text = string.format("%.0f", value)
					else
						SliderAmt.Text = string.format("%.2f", value)
					end
					SliderMain.Size = UDim2.fromScale(percentage, 1)
				else
					if v % 1 == 0 then
						SliderAmt.Text = string.format("%.0f", v)
					else
						SliderAmt.Text = tostring(v)
					end
					SliderMain.Size = UDim2.fromScale(((v - options.min) / (options.max - options.min)), 1)
				end
				options.callback(slider:GetValue())
			end


			function slider:GetValue()
				return tonumber(SliderAmt.Text)
			end

			slider:SetValue(options.default)

			SliderAmt.FocusLost:Connect(function()
				local toNum
				pcall(function()
					toNum = tonumber(SliderAmt.Text)
				end)
				if toNum then
					toNum = math.clamp(toNum, options.min, options.max)
					slider:SetValue(toNum)
				else
					SliderAmt.Text = "only number :<"
				end
			end)

			local Connection;
			table.insert(slider.connections, UIS.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					pcall(function()
						Connection:Disconnect();
						Connection = nil;
					end)
				end
			end))

			--LPH_NO_VIRTUALIZE(function()
			table.insert(slider.connections, Slider.MouseButton1Down:Connect(function()
				if(Connection) then
					Connection:Disconnect();
				end;

				Connection = RS.Heartbeat:Connect(function()
					--options.callback()

						slider:SetValue()

				end)
			end))
			--end)()

			return slider
		end
		
		function tab:NewDropDown(options)
			local dropdown = {}
			
			local Dropdown = Instance.new('Frame', Canvas)
			local DropdownTitle = Instance.new('TextLabel', Dropdown)
			local DropdownSelected = Instance.new('Frame', Dropdown)
			local SelectedOptionCorner = Instance.new('UICorner', DropdownSelected)
			local SelectedText = Instance.new('TextButton', DropdownSelected)
			local DropdownCorner = Instance.new('UICorner', Dropdown)
			
			Dropdown.Name = "Dropdown"
			Dropdown.Position = UDim2.new(0.2606,0,0.5185,0)
			Dropdown.Size = UDim2.new(0,499,0,34)
			Dropdown.BackgroundColor3 = Color3.new(0,0,0)
			Dropdown.BackgroundTransparency = 0.5
			Dropdown.BorderSizePixel = 0
			Dropdown.BorderColor3 = Color3.new(0,0,0)
			Dropdown.ZIndex = 108
			DropdownTitle.Name = "DropdownTitle"
			DropdownTitle.Position = UDim2.new(0.0321,0,0,0)
			DropdownTitle.Size = UDim2.new(0,312,0,34)
			DropdownTitle.BackgroundColor3 = Color3.new(1,1,1)
			DropdownTitle.BackgroundTransparency = 1
			DropdownTitle.BorderSizePixel = 0
			DropdownTitle.BorderColor3 = Color3.new(0,0,0)
			DropdownTitle.Text = options.Name
			DropdownTitle.TextColor3 = Color3.new(0.851,0.851,0.851)
			DropdownTitle.Font = Enum.Font.Gotham
			DropdownTitle.TextSize = 14
			DropdownTitle.ZIndex = 109
			DropdownTitle.TextXAlignment = Enum.TextXAlignment.Left
			DropdownSelected.Name = "DropdownSelected"
			DropdownSelected.Position = UDim2.new(0.6794,0,0.1471,0)
			DropdownSelected.Size = UDim2.new(0,152,0,24)
			DropdownSelected.BackgroundColor3 = Color3.new(0.0706,0.0706,0.0706)
			DropdownSelected.BorderSizePixel = 0
			DropdownSelected.BorderColor3 = Color3.new(0,0,0)
			DropdownSelected.ZIndex = 109
			SelectedOptionCorner.CornerRadius = UDim.new(0,5)
			SelectedText.Name = "SelectedText"
			SelectedText.Position = UDim2.new(0.0321,0,0,0)
			SelectedText.Size = UDim2.new(0,147,0,24)
			SelectedText.BackgroundColor3 = Color3.new(1,1,1)
			SelectedText.BackgroundTransparency = 1
			SelectedText.BorderSizePixel = 0
			SelectedText.BorderColor3 = Color3.new(0,0,0)
			SelectedText.AutoButtonColor = false
			SelectedText.Text = options.default
			SelectedText.TextColor3 = Color3.new(0.851,0.851,0.851)
			SelectedText.Font = Enum.Font.Gotham
			SelectedText.TextSize = 13
			SelectedText.ZIndex = 109
			DropdownCorner.CornerRadius = UDim.new(0,6)
			

			local DropDownOptions = Instance.new('Frame', Main)
			local Frame = Instance.new('Frame', DropDownOptions)
			local UIListLayout = Instance.new('UIListLayout', Frame)

			--Properties

			DropDownOptions.Name = "DropDownOptions"
			DropDownOptions.Position = UDim2.new(1.0211,0,0.1358,0)
			DropDownOptions.Size = UDim2.new(0,100,0,49)
			DropDownOptions.BackgroundColor3 = Color3.new(0,0,0)
			DropDownOptions.BackgroundTransparency = 0.25
			DropDownOptions.BorderSizePixel = 0
			DropDownOptions.BorderColor3 = Color3.new(0,0,0)
			DropDownOptions.Visible = false
			DropDownOptions.AutomaticSize = Enum.AutomaticSize.XY
			DropDownOptions.ZIndex = 110
			Frame.Size = UDim2.new(0,100,0,49)
			Frame.BackgroundColor3 = Color3.new(1,1,1)
			Frame.BackgroundTransparency = 1
			Frame.BorderSizePixel = 0
			Frame.BorderColor3 = Color3.new(0,0,0)
			Frame.AutomaticSize = Enum.AutomaticSize.XY
			Frame.ZIndex = 110
			UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			
			for i, v in pairs(options.options) do
				local Option = Instance.new('TextButton', Frame)
				local Highlight = Instance.new('Frame', Option)
				Option.Name = "Option"
				Option.Position = UDim2.new(0.02,0,0,0)
				Option.Size = UDim2.new(0,98,0,27)
				Option.BackgroundColor3 = Color3.new(1,1,1)
				Option.BackgroundTransparency = 1
				Option.BorderSizePixel = 0
				Option.Text = v
				Option.BorderColor3 = Color3.new(0,0,0)
				Option.TextColor3 = Color3.new(0.8627,0.8627,0.8627)
				Option.Font = Enum.Font.SourceSans
				Option.TextSize = 14
				Option.ZIndex = 111
				Highlight.Name = "Highlight"
				Highlight.Position = UDim2.new(-0.0306,0,0,0)
				Highlight.Size = UDim2.new(0,2,0,27)
				Highlight.BackgroundColor3 = Color3.new(1,1,1)
				Highlight.BorderSizePixel = 0
				Highlight.BorderColor3 = Color3.new(0,0,0)
				Highlight.AutomaticSize = Enum.AutomaticSize.Y
				Highlight.ZIndex = 111
				
				Option.MouseButton1Down:Connect(function()
					SelectedText.Text = v
					DropDownOptions.Visible = false
					options.callback(v)
				end)
			end
			
			SelectedText.MouseButton1Down:Connect(function()
				DropDownOptions.Visible = not DropDownOptions.Visible
			end)
			
			options.callback(options.default)
			
			return dropdown
		end
		
		function tab:NewButton(options)
			local button = {}
			
			local Button = Instance.new('Frame', Canvas)
			local ButtonTitle = Instance.new('TextButton', Button)
			local ButtonCorner = Instance.new('UICorner', Button)

			--Properties

			Button.Name = "Button"
			Button.Position = UDim2.new(0.3338,0,0.6099,0)
			Button.Size = UDim2.new(0,499,0,34)
			Button.BackgroundColor3 = Color3.new(0,0,0)
			Button.BackgroundTransparency = 0.5
			Button.BorderSizePixel = 0
			Button.BorderColor3 = Color3.new(0,0,0)
			Button.ZIndex = 108
			ButtonTitle.Name = "ButtonTitle"
			ButtonTitle.Size = UDim2.new(0,498,0,34)
			ButtonTitle.BackgroundColor3 = Color3.new(1,1,1)
			ButtonTitle.AutoButtonColor = false
			ButtonTitle.BackgroundTransparency = 1
			ButtonTitle.BorderSizePixel = 0
			ButtonTitle.BorderColor3 = Color3.new(0,0,0)
			ButtonTitle.Text = options.Name
			ButtonTitle.TextColor3 = Color3.new(0.851,0.851,0.851)
			ButtonTitle.Font = Enum.Font.Gotham
			ButtonTitle.TextSize = 14
			ButtonTitle.ZIndex = 109
			ButtonCorner.CornerRadius = UDim.new(0,6)
			
			ButtonTitle.MouseButton1Down:Connect(function()
				Library:tween(Button, {BackgroundColor3 = Color3.new(0.756863, 0.756863, 0.756863)})
			end)
			
			ButtonTitle.MouseButton1Up:Connect(function()
				Library:tween(Button, {BackgroundColor3 = Color3.fromRGB(0, 0, 0)})
			end)
			
			ButtonTitle.MouseButton1Click:Connect(function()
				options.callback()
			end)
			
			return button
		end
		
		return tab
	end
	
	return GUI
end

local win = Library:CreateWindow({
    Title = "Saturn Hub"
})

local Tab = win:NewTab({Name ="QB stuff"})
local Tab1 = win:NewTab({Name ="MAG stuff"})
local Tab6 = win:NewTab({Name ="MAGV2 stuff"})
local Tab2 = win:NewTab({Name ="MOVEMENT"})
local Tab3 = win:NewTab({Name ="KICKER aimbot"})
local Tab4 = win:NewTab({Name ="DEFENSIVE stuff"})
local Tab5 = win:NewTab({Name ="OFFENSE stuff"})


LPH_NO_VIRTUALIZE(function()
    task.spawn(function()
        game:GetService("RunService").RenderStepped:Connect(function()
            for _, v in ipairs(workspace:GetChildren()) do
                if v.Name == "Football" and game:GetService("Players").LocalPlayer.Character and getgenv().PullVector == true then
                    local Nigger_Angle = (v.Position - game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position).Unit
                    local Nigger_Distance = (v.Position - game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position).Magnitude

                    if Nigger_Distance < PullVectorDistance then
                        game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Velocity = Nigger_Angle * PullVectorDistance
                    end
                end
            end
        end)
    end)
end)()

local enabled = false
local beamMode = false
local antiOOB = false
local debugMode = false
local antiOOBThreshold = 3
local customLeadDistance = 0

local players = game:GetService("Players")
local debris = game:GetService("Debris")
local userInputService = game:GetService("UserInputService")

--// variables

local player = players.LocalPlayer
local mouse = player:GetMouse()

local camera = workspace.CurrentCamera

local locked = false
local target = nil

local hint = Instance.new("Hint", workspace)

local throwType = "Dive"
local overrideThrowType = ""

local clearFolder = Instance.new("Folder")
clearFolder.Parent = workspace

local data = {
	Angle = 45,
	Direction = Vector3.new(0, 0, 0),
	Power = 0
}

local sidewayRoutes = {"flat", "in/out", "stationary", "curl/comeback"}
local diagonalRoutes = {"slant", "post/corner"}

local offsets = {
	["Dot"] = {
		xLead = function(distance)
			return 3 + (math.max(distance - 25, 0) / 50)
		end,
		routes = {
			["go"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["post/corner"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["slant"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["in/out"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["flat"] = {
				xzOffset = -2.3,
				yOffset = 0
			},
			["curl/comeback"] = {
				xzOffset = -6,
				yOffset = 0
			},
			["stationary"] = {
				xzOffset = 0,
				yOffset = 0
			}
		}
	},
	["Jump"] = {
		xLead = function(distance, route)
			local lead = 11.2 + (distance / 55)
			
			if beamMode and table.find(diagonalRoutes, route) and distance > 175 then
				lead += 0.3
			end
			
			return lead
		end,
		routes = {
			["go"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["post/corner"] = {
				xzOffset = -1,
				yOffset = 0
			},
			["slant"] = {
				xzOffset = -1,
				yOffset = 0
			},
			["in/out"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["flat"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["curl/comeback"] = {
				xzOffset = -12.5,
				yOffset = 0
			},
			["stationary"] = {
				xzOffset = 0,
				yOffset = 0
			}
		}
	},
	["Bullet"] = {
		xLead = function(distance)
			local lead = 22
			local angle = data.Angle
			local angleDistanceAdd = (distance / 100) ^ 1.4

			if angle > 45 then
				local percentange = (angle - 50) / 20
				angleDistanceAdd = distance / (75 - (percentange * 5))
			end

			lead += angleDistanceAdd
			lead += math.max(angle - 45, -5) / 5

			if angle < 40 then
				lead *= 1 - ((45 - angle) / 100)
			end

			return lead
		end,
		routes = {
			["go"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["post/corner"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["slant"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["in/out"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["flat"] = {
				xzOffset = -2.3,
				yOffset = 0
			},
			["curl/comeback"] = {
				xzOffset = -6,
				yOffset = 0
			},
			["stationary"] = {
				xzOffset = 0,
				yOffset = 0
			}
		}
	},
	["Dive"] = {
		xLead = function(distance, route)
			local lead = 20
			local angle = data.Angle
			local angleDistanceAdd = (distance / 100) ^ 1.5

			if angle > 45 then
				local percentage = (angle - 50) / 20
				angleDistanceAdd = distance / (75 - (percentage * 5))
			end
			
			if beamMode then
				lead += player.Character.Humanoid.FloorMaterial == Enum.Material.Air and 7 or 3
			end
			
			if table.find(diagonalRoutes, route) then
				lead -= 7 + (distance / 37)
			end

			lead += angleDistanceAdd
			lead += math.max(angle - 45, -5) / 5

			if angle < 40 then
				lead *= 1 - ((45 - angle) / 100)
			end

			return lead
		end,
		routes = {
			["go"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["post/corner"] = {
				xzOffset = -0.3,
				yOffset = 0
			},
			["slant"] = {
				xzOffset = -0.3,
				yOffset = 0
			},
			["in/out"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["flat"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["curl/comeback"] = {
				xzOffset = -6,
				yOffset = 0
			},
			["stationary"] = {
				xzOffset = 0,
				yOffset = 0
			}
		}
	},
	["Mag"] = {
		xLead = function(distance, route)
			local lead = 21
			local angle = data.Angle
			local angleDistanceAdd = (distance / 100) ^ 1.4

			if angle > 45 then
				local percentage = (angle - 50) / 20
				angleDistanceAdd = distance / (75 - (percentage * 5))
			end

			if beamMode then
				lead += player.Character.Humanoid.FloorMaterial == Enum.Material.Air and 7 or 3
			end

			if table.find(diagonalRoutes, route) then
				lead -= 7 + (distance / 37)
			end

			lead += angleDistanceAdd
			lead += math.max(angle - 45, -5) / 5

			if angle < 40 then
				lead *= 1 - ((45 - angle) / 100)
			end

			return lead
		end,
		routes = {
			["go"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["post/corner"] = {
				xzOffset = -0.3,
				yOffset = 0
			},
			["slant"] = {
				xzOffset = -0.3,
				yOffset = 0
			},
			["in/out"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["flat"] = {
				xzOffset = 0,
				yOffset = 0
			},
			["curl/comeback"] = {
				xzOffset = -6,
				yOffset = 0
			},
			["stationary"] = {
				xzOffset = 0,
				yOffset = 0
			}
		}
	},
}

local throwTypesSwitch = {
	["Dive"] = "Mag",
	["Mag"] = "Jump",
	["Jump"] = "Dot",
	["Dot"] = "Bullet",
	["Bullet"] = "Dive"
}

local beam = Instance.new("Beam"); beam.Parent = workspace.Terrain
local a0, a1 = Instance.new("Attachment"), Instance.new("Attachment"); a0.Parent = workspace.Terrain; a1.Parent = workspace.Terrain
beam.Width0 = 0.5
beam.Width1 = 0.5
beam.Transparency = NumberSequence.new(0)
beam.Color = ColorSequence.new(Color3.fromRGB(152, 81, 0))
beam.Attachment0 = a0
beam.Segments = 3000
beam.Attachment1 = a1

local highlight = Instance.new("Highlight")
highlight.FillColor = Color3.fromRGB(152, 81, 0)

local isPractice = game.PlaceId == 8206123457

local inbPart = Instance.new("Part")
inbPart.CanCollide = false
inbPart.Anchored = true
inbPart.Transparency = 1
inbPart.Position = isPractice and Vector3.new(245, 40.55, 0) or Vector3.new(0, 40.55, 0)
inbPart.Size = Vector3.new(161, 75, 360)
inbPart.Parent = workspace

local ui = game:GetObjects("rbxassetid://17334970363")[1]:Clone()

ui.Parent = gethui()

--// math functions

function roundMoveDirection(direction)
	return Vector3.new(
		math.round(direction.X),
		math.round(direction.Y),
		math.round(direction.Z)
	)
end

function clamp_oobPosition(position)
	inbPart.Size = Vector3.new(161 + (antiOOBThreshold * 2), 75, 360 + (antiOOBThreshold * 2))
	return antiOOB and Vector3.new(
		math.clamp(position.X, -inbPart.Size.X / 2 + inbPart.Position.X, inbPart.Size.X / 2 + inbPart.Position.X),
		math.clamp(position.Y, -inbPart.Size.Y / 2, inbPart.Size.Y / 2),
		math.clamp(position.Z, -inbPart.Size.Z / 2 + inbPart.Position.Z, inbPart.Size.Z / 2 + inbPart.Position.Z)
	) or position
end

function calc_TimeToPeak(from, to, height)
	local g = Vector3.new(0, -28, 0)
	local conversionFactor = 4
	local xMeters = height * conversionFactor

	local a = 0.5 * g.Y
	local b = to.Y - from.Y
	local c = xMeters - from.Y

	local discriminant = b * b - 4 * a * c
	if discriminant < 0 then
		return nil
	end

	local t1 = (-b + math.sqrt(discriminant)) / (2 * a)
	local t2 = (-b - math.sqrt(discriminant)) / (2 * a)

	local t = math.max(t1, t2)
	return t
end

function calc_Vel(from, to, time)
	local g = Vector3.new(0, -28, 0)
	local v0 = (to - from - 0.5*g*time*time)/time;
	local dir = ((from + v0) - from).Unit
	local power = v0.Y / dir.Y
	return v0, dir, math.clamp(math.round(power), 0, 95)
end

function proj_angle(from, to, angle, yLead)
	local y = angle / 90 / 1.9

	local distance = (from - to).Magnitude
	local height = y * distance

	local time = calc_TimeToPeak(from, to, height + yLead)
	local maxTime = (from - to).Magnitude / 95

	local vel = calc_Vel(from, to, math.max(time, maxTime))

	return vel, math.max(time, maxTime)
end

function predVel_ToCharacter(from, character, angle, xLead, yLead, offset, route)
	offset = offset or Vector3.zero

	local y = angle / 90 / 1.9
	local distance = (from - character.HumanoidRootPart.Position).Magnitude
	local height = y * distance

	local isPlayer = players:GetPlayerFromCharacter(character)

	local maxTime = (from - character.HumanoidRootPart.Position).Magnitude / 95
	local time = math.max(calc_TimeToPeak(from, character.HumanoidRootPart.Position, height + xLead), maxTime)

	local moveDirection = isPlayer and character.Humanoid.MoveDirection or (character.Humanoid.WalkToPoint - character.HumanoidRootPart.Position).Unit
	
	if route == "go" then
		local ahead = character.HumanoidRootPart.Position + (moveDirection * 16)
		
		local aheadDirection = (player.Character.HumanoidRootPart.Position - ahead).Unit
		local characterDirection = (player.Character.HumanoidRootPart.Position - character.HumanoidRootPart.Position).Unit
		
		local h = Instance.new("Hint")
		h.Text = (aheadDirection - characterDirection).Magnitude
		h.Parent = workspace
		debris:AddItem(h, 0.1)
	end
	
	local pos = clamp_oobPosition(character.HumanoidRootPart.Position + offset + (moveDirection * 16 * time) + (moveDirection * (2 + xLead)))

	local vel = proj_angle(from, pos, angle, yLead)

	return vel, time
end

function beamProjectile(g, v0, x0, t1)
	local c = 0.5*0.5*0.5;
	local p3 = 0.5*g*t1*t1 + v0*t1 + x0;
	local p2 = p3 - (g*t1*t1 + v0*t1)/3;
	local p1 = (c*g*t1*t1 + 0.5*v0*t1 + x0 - c*(x0+p3))/(3*c) - p2;

	local curve0 = (p1 - x0).Magnitude;
	local curve1 = (p2 - p3).Magnitude;

	local b = (x0 - p3).Unit;
	local r1 = (p1 - x0).Unit;
	local u1 = r1:Cross(b).Unit;
	local r2 = (p2 - p3).Unit;
	local u2 = r2:Cross(b).Unit;
	b = u1:Cross(r1).Unit;

	local cf1 = CFrame.new(
		x0.x, x0.y, x0.z,
		r1.x, u1.x, b.x,
		r1.y, u1.y, b.y,
		r1.z, u1.z, b.z
	)

	local cf2 = CFrame.new(
		p3.x, p3.y, p3.z,
		r2.x, u2.x, b.x,
		r2.y, u2.y, b.y,
		r2.z, u2.z, b.z
	)

	return curve0, -curve1, cf1, cf2;
end

--// routing

function findRoute(character)
	local isPlayer = players:GetPlayerFromCharacter(character)

	local moveDirection = isPlayer and character.Humanoid.MoveDirection or (character.Humanoid.WalkToPoint - character.HumanoidRootPart.Position).Unit
	local distance = (character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude

	local function isDiagonal()
		local absMD = Vector3.new(math.abs(moveDirection.X), 0, math.abs(moveDirection.Z))
		local diff = (absMD - Vector3.new(0.7, 0, 0.7)).Magnitude
		return diff < 0.5
	end

	local function isSideways()
		local direction = (character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Unit
		local highest = math.abs(direction.X) > math.abs(direction.Z) and "Z" or "X"
		return math.abs(moveDirection[highest]) > 0.8
	end

	local function towardsQB()
		local newDistance = ((character.HumanoidRootPart.Position + (moveDirection * 16)) - player.Character.HumanoidRootPart.Position).Magnitude
		return (distance - newDistance) > 12
	end

	local requirements = {
		["go"] = function()
			return not isDiagonal() and not towardsQB()
		end,
		["post/corner"] = function()
			return isDiagonal() and not towardsQB() and distance > 125
		end,
		["slant"] = function()
			return isDiagonal() and not towardsQB() and distance <= 125
		end,
		["in/out"] = function()
			return isSideways() and distance > 125
		end,
		["flat"] = function()
			return isSideways() and distance <= 125
		end,
		["curl/comeback"] = function()
			return towardsQB()
		end,
		["stationary"] = function()
			return moveDirection.Magnitude <= 0
		end,
	}

	local route = nil

	for routeName, func in pairs(requirements) do
		route = func() and routeName or route
		if route then break end
	end

	hint.Text = route

	return route, moveDirection
end

--// misc functions

local function findTarget()
	-- not skidded from aki trust
	local cc = workspace.CurrentCamera
	local target = nil
	local dist = math.huge
	for i,v in pairs(players:GetPlayers()) do
		if v.Name ~= player.Name then
			if v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("HumanoidRootPart") and v.Team == player.Team then
				local screenpoint,onscreen = cc:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
				local check = (Vector2.new(userInputService:GetMouseLocation().X,userInputService:GetMouseLocation().Y)-Vector2.new(screenpoint.X,screenpoint.Y)).magnitude
				if check < dist then
					target = v.Character
					dist = check
				end
			end
		end
	end
	return target
end

--// misc events

clearFolder.ChildAdded:Connect(function(child)
	debris:AddItem(child, 3)
end)

--// input handling

local inputFuncs = {
	[Enum.KeyCode.R] = function()
		data.Angle = math.clamp(data.Angle + 5, 5, 70)
	end,
	[Enum.KeyCode.F] = function()
		data.Angle = math.clamp(data.Angle - 5, 5, 70)
	end,
	[Enum.KeyCode.Q] = function()
		locked = not locked
	end,
	[Enum.KeyCode.Z] = function()
		throwType = throwTypesSwitch[throwType]
	end,
}

userInputService.InputBegan:Connect(function(input, gp)
	if gp then return end;
	(inputFuncs[input.KeyCode] or function() end)()
end)

--// hooking

local __namecall; __namecall = hookmetamethod(game, "__namecall", function(self, ...)
	local method = getnamecallmethod()
	local args = {...}
	if args[1] == "Clicked" and enabled then
		local nwArgs = {"Clicked", player.Character.Head.Position, player.Character.Head.Position + data.Direction * 10000, (isPractice and data.Power) or 95, data.Power}

		if debugMode then
			local from = player.Character.Head.Position

			local vel = data.Direction * data.Power
			local part = Instance.new("Part", clearFolder)

			part.Size = Vector3.new(1, 1, 100)
			part.Anchored = true
			part.CanCollide = false
			part.CFrame = CFrame.lookAt(from, from + vel)
			part.Transparency = 0.5
			part.Color = Color3.fromRGB(152, 81, 0)
			print(vel.Magnitude, part.Orientation.X, data.Angle)
		end

		return __namecall(self, unpack(nwArgs))	
	end
	return __namecall(self, ...)
end)

--// main

task.spawn(function()
	while true do
		task.wait()
		local s, e = pcall(function()
			target = locked and target or findTarget()

			highlight.OutlineColor = locked and Color3.fromRGB(0, 0, 0) or Color3.fromRGB(0, 0, 0)
			highlight.FillColor = locked and Color3.fromRGB(209, 118, 0) or Color3.fromRGB(209, 118, 0)

			hint.Parent = debugMode and workspace or nil

			if target and player.PlayerGui:FindFirstChild("BallGui") and enabled then
				local route, md = findRoute(target)
				local distance = (player.Character.HumanoidRootPart.Position - target.HumanoidRootPart.Position).Magnitude

				data.Angle = (beamMode or throwType == "Bullet") and (((player.Character.Humanoid.FloorMaterial == Enum.Material.Air and distance * 1.1 or distance) / 8) ^ 1.01) or data.Angle

				if table.find(sidewayRoutes, route) and (beamMode or throwType == "Bullet") then
					data.Angle = distance > 135 and math.max((6 + (distance / 75)) ^ 1.3, 10) or 10
					if throwType == "Jump" then
						data.Angle = math.max((data.Angle / 1.7) ^ 1.13, 5)
						if route == "stationary" then
							data.Angle = math.max(data.Angle / 1.3, 5)
						end
					end
				end

				if (not beamMode and throwType ~= "Bullet") and (data.Angle % 5 ~= 0) then
					data.Angle = 45
				end

				local xLead = offsets[(((beamMode or throwType == "Bullet") and table.find(sidewayRoutes, route) and "Dot") or (throwType == "Bullet" and "Dive") or throwType)].xLead(distance, route) + offsets[((beamMode or throwType == "Bullet") and table.find(sidewayRoutes, route) and "Dot" or throwType)].routes[route].xzOffset + ((beamMode and not table.find(sidewayRoutes, route)) and 10 - (distance / 100) or 0)
				xLead += customLeadDistance

				if throwType == "Jump" and table.find(diagonalRoutes, route) and beamMode then
					xLead -= 10
				end

				if throwType == "Jump" and table.find(sidewayRoutes, route) and beamMode and player.Character.Humanoid.FloorMaterial == Enum.Material.Air then
					xLead += 2
				end
				
				local vel, airtime = predVel_ToCharacter(player.Character.Head.Position, target, data.Angle, xLead, 0, (throwType == "Jump" and table.find(sidewayRoutes, route) and Vector3.new(0, 7, 0)) or (throwType == "Mag" and Vector3.new(0, 2 - (math.max(distance - 100, 0) / 50), 0)), route)

				hint.Text = route.." "..xLead.." "..distance

				local power = math.min(math.round(vel.Magnitude), 95)
				local direction = vel.Unit

				local c0, c1, cf1, cf2 = beamProjectile(Vector3.new(0, -28, 0), direction * power, player.Character.Head.Position + direction * 5, airtime * 1.5)
				beam.CurveSize0 = c0
				beam.CurveSize1 = c1
				beam.Color = ColorSequence.new(Color3.fromRGB(255, 171, 0))
				a0.CFrame = a0.Parent.CFrame:Inverse() * cf1
				a1.CFrame = a1.Parent.CFrame:Inverse() * cf2

				highlight.Parent = target
				highlight.Adornee = target

				data.Power = power
				data.Direction = direction

				ui.Frame.Airtime.Value.Text = (math.round(airtime * 100) / 100).."s"
				ui.Frame.Angle.Value.Text = math.round(data.Angle * 10) / 10
				ui.Frame.Mode.Value.Text = throwType
				ui.Frame.Power.Value.Text = power
				ui.Frame.Target.Value.Text = target.Name
			end
			beam.Enabled = player.PlayerGui:FindFirstChild("BallGui") and enabled
			highlight.Enabled = player.PlayerGui:FindFirstChild("BallGui") and enabled
			ui.Enabled = player.PlayerGui:FindFirstChild("BallGui") and enabled
		end);

		((not s and debugMode) and warn or function() end)(e)
	end
end)







Tab:NewToggle({
	Name = "QB Aimbot",
	default = false,
	callback = function(Value)
        enabled = Value
    end
})

Tab:NewToggle({
	Name = "Beam mode",
	default = false,
	callback = function(Value)
        if enabled then
            beamMode = Value
        end
    end
})




Tab:NewToggle({
	Name = "Debug mode",
	Name = "Debug mode",
	default = false,
	callback = function(Value)
        if enabled then
            debugMode = Value
        end
    end
})







Tab:NewToggle({
	Name = "anti oob",
	default = false,
	callback = function(Value)
        antiOOB = Value
    end
})

Tab:NewSlider({
    Name = "anti oob dist",
    min = 0,
    max = 10,
    default = 0,
    callback = function(Value)
        antiOOBThreshold = Value
    end
})

Tab:NewSlider({
    Name = "Lead distance",
    min = 0,
    max = 10,
    default = 0,
    callback = function(Value)
        customLeadDistance = Value
    end
})






local players = game:GetService("Players")
local userInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local remotes = replicatedStorage:FindFirstChild("Remotes")
local characterSoundEvent = remotes:FindFirstChild("CharacterSoundEvent")
local player = game:GetService("Players").LocalPlayer
local runService = game:GetService("RunService")
--local human


local saturn = {

    Catching = {
        mags = false,
        range = 0
    }
}

Tab1:NewToggle({
    Name = "Mags",
    default = false,
    callback = function(v)
        saturn.Catching.mags = v
    end
})

local magToggle = Tab1:NewSlider({
    Name = "Mag range",
    min = 0,
    max = 30,
    default = 0,
    callback = function(v)
		saturn.Catching.range = v
    end
})
--rbxasset
Tab1:NewDropDown({
    Name = "mag type",
    options = {
        "Blatant",
        "Regular",
        "Legit",
		"League"
    },
	
    default = "Normal",
    callback = function(v)
        if v == "Blatant" then
            magToggle:SetValue(30)
        elseif v == "Regular" then
            magToggle:SetValue(13)
        elseif v == "Legit" then
            magToggle:SetValue(10)
		elseif v == "League" then
            magToggle:SetValue(6)
        end
    end,
})

local autokick = false 

task.spawn(function()

getgenv().Variables = {}

	Variables.Players = game:GetService("Players")
	Variables.ReplicatedStorage = game:GetService("ReplicatedStorage")
	Variables.UserInputService = game:GetService("UserInputService")
	Variables.Client = Variables.Players.LocalPlayer
	Variables.Character = Variables.Client.Character or Variables.Client.CharacterAdded:Wait()

	Variables.Client.CharacterAdded:Connect(function(Character)
		Variables.Character = Character 
	end)

	local Aimbot = {}

	function Aimbot:GetAccuracyArrow(Arrows)
		local Y = 0
		local Arrow1 = nil

		for _, Arrow in pairs(Arrows) do
			if Arrow.Position.Y.Scale > Y then
				Y = Arrow.Position.Y.Scale
				Arrow1 = Arrow 
			end
		end

		return Arrow1
	end

	Variables.Client.PlayerGui.ChildAdded:Connect(function(child)
		if child.Name == "KickerGui" and autokick == true then
			local KickerGui = child 
			local Meter = KickerGui:FindFirstChild("Meter")
			local Cursor = Meter:FindFirstChild("Cursor")
			local Arrows = {}

			for i,v in pairs(Meter:GetChildren()) do
				if string.find(v.Name:lower(), "arrow") then
					table.insert(Arrows, v)
				end
			end 

			repeat task.wait() until Cursor.Position.Y.Scale < 0.02
			mouse1click()
			repeat task.wait() until Cursor.Position.Y.Scale >= Aimbot:GetAccuracyArrow(Arrows).Position.Y.Scale + (.03 / (100 / 100))
			mouse1click()
		end
	end)
end)

Tab3:NewToggle({
	Name = "kicker aimbot PRESS ONCE AUTO DOES IT",
	default = false,
	callback = function(v)
	autokick = v
end})



local connection

Tab4:NewToggle({
	Name = "tp tackle",
	default = false,
	callback = function(v)
	if v then
		connection = game:GetService("Players").LocalPlayer:GetMouse().Button1Down:Connect(function()
			for i, v in pairs(game.workspace:GetDescendants()) do
				if v.Name == "Football" and v:IsA("Tool") then
					local toolPosition = v.Parent.HumanoidRootPart.Position
					local playerPosition = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position
					if (toolPosition - playerPosition).Magnitude <= tprange then
						game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = v.Parent.HumanoidRootPart.CFrame + Vector3.new(1, 1, 1)
					end
				end
			end
		end)
	else
		if connection then
			connection:Disconnect() -- Disconnect the mouse click event only if it exists
		end
	end
end})
--game.player
Tab4:NewSlider({
	Name = "tp tackle range",
	min = 0,
	max = 15,
	default = 0,
	callback = function(v)
	tprange = v
end})
--lag






local swatreachmain = false
local player = game:GetService("Players").LocalPlayer
local swatDistance = math.huge
local swatted = false
local userInputService = game:GetService("UserInputService")

local function isFootball(fb)
	return fb and fb:FindFirstChildWhichIsA("RemoteEvent")
end

local function getNearestBall(checkFunc)
	local lowestDistance = math.huge
	local lowestFB = nil
	for index, part in pairs(workspace:GetChildren()) do
		if isFootball(part) and not part.Anchored then
			if checkFunc then
				if not checkFunc(part) then
					continue
				end
			end
			local distance = (player.Character.HumanoidRootPart.Position - part.Position).Magnitude
			if distance < lowestDistance then
				lowestFB = part
				lowestDistance = distance
			end
		end
	end
	return lowestFB, lowestDistance
end

local function getNearestPartToPartFromParts(parts, part)
	local lowestMagnitude = math.huge
	local lowestPart = nil
	for index, p in pairs(parts) do
		local dis = (part.Position - p.Position).Magnitude
		if dis < lowestMagnitude then
			lowestMagnitude = dis
			lowestPart = p
		end
	end
	return lowestPart
end

local function initCharacter(char)
	while swatreachmain do
		task.wait()
		local ball = getNearestBall()
		if ball and swatted then
			local distance = (player.Character.HumanoidRootPart.Position - ball.Position).Magnitude
			if distance < swatDistance then
				local catch = getNearestPartToPartFromParts({player.Character["CatchLeft"], player.Character["CatchRight"]}, ball)
				firetouchinterest(ball, catch, 0)
				firetouchinterest(ball, catch, 1)
			end
		end
	end
end

userInputService.InputBegan:Connect(function(input, gp)
	if not gp then
		if input.KeyCode == Enum.KeyCode.R and not swatted then
			swatted = true
			task.wait(1.5)
			swatted = false
		end
	end
end)

local function updateCharacter(character)
	if swatreachmain then
		initCharacter(character)
	end
end

player.CharacterAdded:Connect(updateCharacter)
--jump
Tab4:NewToggle({
	Name = "swat reach",
	default = false,
	callback = function(value)
	swatreachmain = value
	if value then
		updateCharacter(player.Character) 
	end
end})

if swatreachmain then
	initCharacter(player.Character)
end

-- Auto Swat

local autoswatv = 0

local enabledd = false
--slider
local function autoswatfunction()
	if enabledd then
        local player = game:GetService("Players").LocalPlayer
		local character = player.Character or player.CharacterAdded:Wait()
		local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
		local RunService = game:GetService("RunService")

		local function checkDistance(part)
			local distance = (part.Position - humanoidRootPart.Position).Magnitude
			if distance <= autoswatv then
				keypress(0x52)
				keyrelease(0x52)
				task.wait()
			end
		end
		local function updateDistances()
			for _, v in pairs(game.Workspace:GetDescendants()) do
				if v.Name == "Football" and v:IsA("BasePart") then
					checkDistance(v)
				end
			end
		end
		connection = RunService.Heartbeat:Connect(updateDistances)
	else
		if connection then
			connection:Disconnect()
			connection = nil
		end
	end
end
--uni
Tab4:NewToggle({
	Name = "auto swat",
	default = false,
	callback = function(v)
	enabledd = v
	autoswatfunction()
end})
--lag
Tab4:NewSlider({
	Name = "swat reach range laggy",
	min = 1,
	max = 50,
	default = 0,
	callback = function(v)
	autoswatv = v
end})

Tab6:NewToggle({
	Name = "Jump predictions",
	default = false,
	callback = function(v)
	if v then
        local player = game:GetService("Players").LocalPlayer

		local function handleBall(ball)
			if ball.Name == "Football" and ball:IsA("BasePart") then
				local v0 = ball.Velocity
				local x0 = ball.Position
				local dt = 1/30
				local grav = Vector3.new(0, -28, 0)
				local points = {
					[1] = x0
				}
				local function check(p, v0)
					local raycastParams = RaycastParams.new()
					raycastParams.RespectCanCollide = true
					local ray = workspace:Raycast(p, Vector3.new(0, -1000, 0), raycastParams)
					local ray2 = workspace:Raycast(p, Vector3.new(0, -7.2 * 2, 0), raycastParams)
					return ray and not ray2
				end
				while true do
					if not check(points[#points], v0) then
						if v0.Y < 0 then
							break
						end
					end
					local currentPoint = points[#points]
					v0 += grav * dt
					points[#points + 1] = currentPoint + (v0 * dt)
				end
				local optimal = points[#points]
				local part = Instance.new("Part")
				part.Anchored = true
				part.CanCollide = false
				part.Position = Vector3.new(optimal.X, player.Character.HumanoidRootPart.Position.Y + 1.5, optimal.Z)
				part.Parent = workspace
				part.Material = Enum.Material.Neon
				part.Size = Vector3.new(1.5, 1.5, 1.5)
				repeat task.wait() until ball.Parent ~= workspace
				part:Destroy()
			end
		end
--slant
		local function handleChildAdded(ball)
			task.wait()
			handleBall(ball)
		end
		eventConnection = workspace.ChildAdded:Connect(handleChildAdded)
	else
		if eventConnection then
			eventConnection:Disconnect()
			eventConnection = nil
		end
	end
end})


--qb

--FindTarget
Tab:NewToggle({
	Name = "Football landing predictions",
	default = false,
	callback = function(v)
	if v and not toggleActive then
		toggleActive = true
		eventConnection = workspace.ChildAdded:Connect(function(b)
			if b.Name == "Football" and b:IsA("BasePart") then
				task.wait()
				local vel = b.Velocity
				local pos = b.Position
				local c0, c1, cf1, cf2 = beamProjectile(Vector3.new(0, -28, 0), vel, pos, 10)
				local beam = Instance.new("Beam")
				local a0 = Instance.new("Attachment")
				local a1 = Instance.new("Attachment")
				beam.Color = ColorSequence.new(predictioncolor)
				beam.Transparency = NumberSequence.new(0, 0)
				beam.CurveSize0 = c0
				beam.CurveSize1 = c1
				beam.Name = "Hitbox"
				beam.Parent = workspace.Terrain
				beam.Transparency = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 1),
					NumberSequenceKeypoint.new(0.01, 0),
					NumberSequenceKeypoint.new(1, 0),
					NumberSequenceKeypoint.new(1, 0.01),
				})
				beam.Segments = 1750
				a0.Parent = workspace.Terrain
				a1.Parent = workspace.Terrain
				a0.CFrame = a0.Parent.CFrame:Inverse() * cf1
				a1.CFrame = a1.Parent.CFrame:Inverse() * cf2
				beam.Attachment0 = a0
				beam.Attachment1 = a1
				beam.Width0 = 0.5
				beam.Width1 = 0.5
				repeat task.wait() until b.Parent ~= workspace
				a0:Destroy()
				a1:Destroy()
			end
		end)
	elseif not Value and toggleActive then
		toggleActive = false
		if eventConnection then
			eventConnection:Disconnect()
		end
	end
end})


Tab:NewDropDown({
	Name = "prediction color",
	options = {
		"White",
		"Blue",
        "Red",
        "Pink",
        "Green"
	},
	default = "White",
	callback = function(v)
	if v == "White" then
		predictioncolor = Color3.fromRGB(255, 255, 255)
	elseif v == "Blue" then
		predictioncolor = Color3.fromRGB(0, 212, 255)
	elseif v == "Pink" then
		predictioncolor = Color3.fromRGB(253, 137, 245)
	elseif v == "Red" then
		predictioncolor = Color3.fromRGB(255, 0, 0)
	elseif v == "Green" then
		predictioncolor = Color3.fromRGB(0, 255, 115)
	end
end})


local isAntiJamEnabled = false

local function updateCollisionState()
	while true do
		if isAntiJamEnabled then
			if game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Head") and game:GetService("Players").LocalPlayer.Character.Head.CanCollide then
				for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
					if player ~= game:GetService("Players").LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
						pcall(function()
							player.Character.Torso.CanCollide = false
							player.Character.Head.CanCollide = false
						end)
					end
				end
			end
		else
			if game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Head") and not game:GetService("Players").LocalPlayer.Character.Head.CanCollide then
				game:GetService("Players").LocalPlayer.Character.Torso.CanCollide = true
				game:GetService("Players").LocalPlayer.Character.Head.CanCollide = true
			end
		end
		task.wait()
	end
end

-- Define the GUI

Tab:NewToggle({
	Name = "Anti Jam",
	default = false,
	callback = function(enabled)
        isAntiJamEnabled = enabled
    end
})
--local player
-- Start the function to update collision state
spawn(updateCollisionState)


local AutoFollowQb = false
local followCarrierTask

local function FollowCarrier()
    while AutoFollowQb do
        local carrier = game:GetService("ReplicatedStorage").Values.Carrier.Value
        if carrier and carrier:IsDescendantOf(game:GetService("Players")) and carrier.Team ~= game:GetService("Players").LocalPlayer.Team then
            local humanoid = game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid:MoveTo(carrier.Character.Torso.Position)
            end
        end
        wait()
    end
end

local function ToggleFollowCarrier(value)
    AutoFollowQb = value
    if value then
        followCarrierTask = task.spawn(FollowCarrier)
    else
        if followCarrierTask then
            followCarrierTask:cancel()
        end
    end
end

Tab4:NewToggle({
	Name = "auto follow qb",
	default = false,
	callback = ToggleFollowCarrier,
})



Tab4:NewSlider({
	Name = "follow qb distance",
	min = 1,
	max = 30,
	default = 0,
	callback = function(set)

end,
})


local player = game:GetService("Players").LocalPlayer
local userInputService = game:GetService("UserInputService")
local runService = game:GetService("RunService")

local jumpCooldown = 0.5  -- Adjust this value based on your game's mechanics
local lastJumpTime = 0
local antiAceEnabled = false  -- Initial state of the anti ace toggle

local function PerformJump()
    -- Perform the jump action
    -- You might want to adjust the code here to simulate jumping
end

local function PerformDive()
    -- Perform the dive action
    -- You might want to adjust the code here to simulate diving
end

userInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space then
        if antiAceEnabled then
            local currentTime = tick()
            if currentTime - lastJumpTime > jumpCooldown then
                PerformJump()
                lastJumpTime = currentTime
            else
                PerformDive()
            end
        else
            -- Perform the default jump or dive action
        end
    end
end)

runService.RenderStepped:Connect(function()
    if antiAceEnabled then
        -- Check for the appropriate condition to trigger the automatic dive
        -- For example, if you detect that the character is in mid-air and has jumped
        -- Implement the automatic dive action here
    end
end)

Tab5:NewToggle({
	Name = "anti ace",
	default = false,
	callback = function(state)
        antiAceEnabled = state
    end,
})

local player = game:GetService("Players").LocalPlayer
local runService = game:GetService("RunService")

local lagEffectEnabled = false  -- Initial state of the lag effect toggle
local lagMultiplier = 0.5  -- Adjust this value to control the lag effect strength

local function ApplyLagEffect()
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                local currentVelocity = rootPart.Velocity
                rootPart.Velocity = currentVelocity * lagMultiplier
            end
        end
    end
end

runService.RenderStepped:Connect(function()
    if lagEffectEnabled then
        ApplyLagEffect()
    end
end)

Tab6:NewToggle({
	Name = "makes you look laggy for ms",
	default = false,
	callback = function(state)
        lagEffectEnabled = state
    end,
})
--hitbox
Tab6:NewSlider({
	Name = "lag adjust",
	min = 0,
	max = 1,
	default = 0,
	callback = function(value)
        lagMultiplier = value
    end,
})


local UserInputService = game:GetService("UserInputService")
local JumpPowerMultiplier = 1.5  -- Default jump height multiplier
local OriginalJumpPower = game:GetService("Players").LocalPlayer.Character.Humanoid.JumpPower
local JumpToggleEnabled = false

local function OnJumpRequest(actionName, inputState, inputObject)
    if inputState == Enum.UserInputState.Begin then
        local character = game:GetService("Players").LocalPlayer.Character
        local humanoid = character and character:FindFirstChild("Humanoid")
        
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Physics)
            humanoid:Move(Vector3.new(0, humanoid.JumpPower, 0))  -- Perform a standard jump
        end
    end
end
--game.player
Tab2:NewToggle({
	Name = "jump boost",
	default = false,
	callback = function(state)
        JumpToggleEnabled = state
        local character = game:GetService("Players").LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.JumpPower = state and OriginalJumpPower * JumpPowerMultiplier or OriginalJumpPower
            end
        end
    end,
})
--game.player
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent and JumpToggleEnabled and input.KeyCode == Enum.KeyCode.Space then
        OnJumpRequest()
    end
end)

Tab5:NewButton({
	Name = "FPS BOOST",
	callback = function(state)
        
local decalsyeeted = true -- Leaving this on makes games look shitty but the fps goes up by at least 20.
local g = game
local w = g.Workspace
local l = g.Lighting
local t = w.Terrain
t.WaterWaveSize = 0
t.WaterWaveSpeed = 0
t.WaterReflectance = 0
t.WaterTransparency = 0
l.GlobalShadows = false
l.FogEnd = 9e9
l.Brightness = 0
settings().Rendering.QualityLevel = "Level01"
for i, v in pairs(g:GetDescendants()) do
    if v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
        v.Material = "Plastic"
        v.Reflectance = 0
    elseif v:IsA("Decal") or v:IsA("Texture") and decalsyeeted then
        v.Transparency = 1
    elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
        v.Lifetime = NumberRange.new(0)
    elseif v:IsA("Explosion") then
        v.BlastPressure = 1
        v.BlastRadius = 1
    elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") then
        v.Enabled = false
    elseif v:IsA("MeshPart") then
        v.Material = "Plastic"
        v.Reflectance = 0
        v.TextureID = 10385902758728957
    end
end
for i, e in pairs(l:GetChildren()) do
    if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") then
        e.Enabled = false
    end
end

    end,
})

local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local moveDistance = 5
local isEnabled = false


local function moveCharacter()
    local newPosition = character.PrimaryPart.Position + character.PrimaryPart.CFrame.lookVector * moveDistance
    character:SetPrimaryPartCFrame(CFrame.new(newPosition))
end


local function toggleCallback(value)
    isEnabled = value
end


local function onKeyPress(input)
    if isEnabled and input.KeyCode == Enum.KeyCode.F then
        moveCharacter()
    end
end

local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(onKeyPress)


Tab5:NewToggle({
	Name = "F to quick tp",
	default = false,
	callback = toggleCallback
})
--getservice


--emulator

Tab2:NewToggle({
	Name = "enable ws",
	default = false,
	callback = function(state)
        getgenv().Walkspeed = state
        while getgenv().Walkspeed == true do
            game:GetService("Players").LocalPlayer.Character.Humanoid.WalkSpeed = _G.SPEED
            wait()
        end
        if getgenv().Walkspeed == false then
            game:GetService("Players").LocalPlayer.Character.Humanoid.WalkSpeed = 20
        end
    end,
})

Tab2:NewToggle({
	Name = "enable jp",
	default = false,
	callback = function(state)
        getgenv().JP = state
        while getgenv().JP == true do
            game:GetService("Players").LocalPlayer.Character.Humanoid.JumpPower = _G.Jump
            wait()
        end
        if getgenv().JP == false then
            game:GetService("Players").LocalPlayer.Character.Humanoid.JumpPower = 50
        end
    end,
})



Tab2:NewSlider({
	Name = "ws adjust",
	min = 20,
	max = 27,
	default = 20,
	callback = function(value)
        _G.SPEED = value
    end,
})

Tab2:NewSlider({
	Name = "jp adjust",
	min = 50,
	max = 65,
	default = 50,
	callback = function(value)
        _G.Jump = value
    end,
})



--game.player
local qbaimpred = false
Tab:NewToggle({
	Name = "qb aim pred",
	default = false,
	callback = function(v)
	qbaimpred = v -- Update the toggle state

	if qbaimpred then
		local beam = Instance.new("Beam")
		local a0 = Instance.new("Attachment")
		local a1 = Instance.new("Attachment")   
		local mouse = game:GetService("Players").LocalPlayer:GetMouse()
		beam.Color = ColorSequence.new(Color3.fromRGB(0, 0, 0))
		beam.Transparency = NumberSequence.new(0, 0)
		beam.Segments = 10 * 300
		beam.Name = "Hitbox"
		beam.Parent = workspace.Terrain
		a0.Parent = workspace.Terrain
		a1.Parent = workspace.Terrain
		beam.Attachment0 = a0
		beam.Attachment1 = a1
		beam.Width0 = 0.5
		beam.Width1 = 0.5
		while qbaimpred do
			task.wait()
			if game:GetService("Players").LocalPlayer.Character:FindFirstChild("Football") and game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("BallGui") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Head") then
				local power = tonumber(game:GetService("Players").LocalPlayer.PlayerGui.BallGui.Frame.Disp.Text)
				local direction = (mouse.Hit.Position - workspace.CurrentCamera.CFrame.Position).Unit
				local vel = power * direction
				local origin = game:GetService("Players").LocalPlayer.Character.Head.Position + direction * 5
				local c0, c1, cf1, cf2 = beamProjectile(Vector3.new(0, -28, 0), power * direction, game:GetService("Players").LocalPlayer.Character.Head.Position + (direction * 5), 7)
				a0.CFrame = a0.Parent.CFrame:Inverse() * cf1
				a1.CFrame = a1.Parent.CFrame:Inverse() * cf2
				beam.CurveSize0 = c0
				beam.CurveSize1 = c1
			end
		end
		beam:Destroy() -- Clean up the beam when toggled off
	else
		-- Toggle turned off
		-- Add any additional code here to handle the toggle turning off
	end
end})
--local t
local autokick = false 
--game.player
task.spawn(function()

getgenv().Variables = {}

	Variables.Players = game:GetService("Players")
	Variables.ReplicatedStorage = game:GetService("ReplicatedStorage")
	Variables.UserInputService = game:GetService("UserInputService")
	Variables.Client = Variables.Players.LocalPlayer
	Variables.Character = Variables.Client.Character or Variables.Client.CharacterAdded:Wait()

	Variables.Client.CharacterAdded:Connect(function(Character)
		Variables.Character = Character 
	end)

	local Aimbot = {}

	function Aimbot:GetAccuracyArrow(Arrows)
		local Y = 0
		local Arrow1 = nil

		for _, Arrow in pairs(Arrows) do
			if Arrow.Position.Y.Scale > Y then
				Y = Arrow.Position.Y.Scale
				Arrow1 = Arrow 
			end
		end

		return Arrow1
	end

	Variables.Client.PlayerGui.ChildAdded:Connect(function(child)
		if child.Name == "KickerGui" and autokick == true then
			local KickerGui = child 
			local Meter = KickerGui:FindFirstChild("Meter")
			local Cursor = Meter:FindFirstChild("Cursor")
			local Arrows = {}

			for i,v in pairs(Meter:GetChildren()) do
				if string.find(v.Name:lower(), "arrow") then
					table.insert(Arrows, v)
				end
			end 

			repeat task.wait() until Cursor.Position.Y.Scale < 0.02
			mouse1click()
			repeat task.wait() until Cursor.Position.Y.Scale >= Aimbot:GetAccuracyArrow(Arrows).Position.Y.Scale + (.03 / (100 / 100))
			mouse1click()
		end
	end)
end)
 

Tab3:NewToggle({
	Name = "kicker aimbotv2",
	default = false,
	callback = function(t)
        autokick = t
    end,
})

Tab3:NewSlider({
	Name = "accuracy for V2",
	min = 1,
	max = 100,
	default = 0,
	callback = function(value)
    
    end,
})
--hitbox
local autoCatchDistance = 10

local function autoCatch()
    while true do
        task.wait()
        local ball = getNearestBall()
        if ball then
            local distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance < autoCatchDistance then
                keypress(0x43) 
                keyrelease(0x43) 
                task.wait(1.5)
            end
        end
    end
end

Tab6:NewToggle({
	Name = "auto catch",
	default = false,
	callback = function(value)
        if value then

            autoCatch()
        end
    end,
})

Tab6:NewSlider({
	Name = "auto catch distance",
	min = 1,
	max = 20,
	default = 0,
	callback = function(value)
    
        autoCatchDistance = value
    end,
})







local player = game:GetService("Players").LocalPlayer
local runService = game:GetService("RunService")

local pullVectorEnabled = false
local pullVectorDistance = 10

function magBall(ball)
    if ball and player.Character and pullVectorEnabled then
        local direction = (ball.Position - player.Character.HumanoidRootPart.Position).Unit
        player.Character.HumanoidRootPart.Velocity = direction * pullVectorDistance  
    end
end

runService.Stepped:Connect(function()
    for _, ball in ipairs(workspace:GetChildren()) do
        if ball.Name == "Football" and ball:IsA("BasePart") then
            local magnitude = (player.Character.HumanoidRootPart.Position - ball.Position).Magnitude
            if magnitude < pullVectorDistance and pullVectorEnabled then
                magBall(ball)
            end
        end
    end
end)

Tab1:NewToggle({
	Name = "pull vector LEGIT",
	default = false,
	callback = function(t)
        pullVectorEnabled = t
    end,
})




Tab1:NewSlider({
	Name = "pull vector LEGIT",
	min = 0,
	max = 15,
	default = 0,
	callback = function(value)
        pullVectorDistance = value
    end,
})





getgenv().Football_Vector = 0
getgenv().Pull_Vector = false

task.spawn(function()
    game:GetService("RunService").Heartbeat:Connect(function()
        for _, Value in pairs(workspace:GetChildren()) do
            if Value.Name == "Football" and Value:IsA("BasePart") then
                local Direction = (Value.Position - game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position).Unit

                if game:GetService("Players").LocalPlayer:DistanceFromCharacter(Value.Position) <= getgenv().Football_Vector and getgenv().Pull_Vector then
                    game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Velocity = Direction * (getgenv().Football_Vector)
                end
            end
        end
    end)
end)


Tab1:NewToggle({
	Name = "pull vector BLATANT",
	default = false,
	callback = function(Value)
        getgenv().Pull_Vector = Value
    end
})

Tab1:NewSlider({
	Name = "pull vector BLATANT",
	min = 0,
	max = 60,
	default = 0,
	callback = function(Value)
        if getgenv().Pull_Vector then
            getgenv().Football_Vector = Value
        end
    end,
})



--mag script

task.spawn(function()
    while true do
        task.wait()

        if not saturn.Catching.mags then
            continue
        end

        for i, v in pairs(game:GetService("Workspace"):GetChildren()) do
            if v.Name == "Football" and v:IsA("BasePart") then
                if (game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position - v.Position).magnitude <= saturn.Catching.range then
                    pcall(function() -- So no error if catch right doesnt exist yet
                        firetouchinterest(game:GetService('Players').LocalPlayer.Character["CatchRight"], v, 0)
                        firetouchinterest(game:GetService('Players').LocalPlayer.Character["CatchRight"], v, 0)
                        firetouchinterest(game:GetService('Players').LocalPlayer.Character["CatchRight"], v, 1)
                        firetouchinterest(game:GetService('Players').LocalPlayer.Character["CatchRight"], v, 1)
                    end)
                end
            end
        end
    end
end)



local RunService = game:GetService("RunService")
local HitboxExpanderEnabled = false
local HitboxExpanderSize = 10

--angle
Tab6:NewToggle({
	Name = "hitbox extender",
	default = false,
	callback = function(toggleValue)
 HitboxExpanderEnabled = toggleValue
    end,
})
--mags type
Tab6:NewSlider({
	Name = "extender distance",
	min = 1,
	max = 30,
	default = 0,
	callback = function(sliderValue)
    HitboxExpanderSize = sliderValue
    end,
})

spawn(function()
    while true do
        wait()
        if HitboxExpanderEnabled then
            for _, v in ipairs(workspace:GetChildren()) do
                if v.Name == "Football" and v:IsA("BasePart") then
                    for _, vp in ipairs(getconnections(v:GetPropertyChangedSignal("Size"))) do
                        vp:Disable()
                    end
                    v.CanCollide = false
                    v.Size = Vector3.new(HitboxExpanderSize, HitboxExpanderSize, HitboxExpanderSize)
                end
            end
        end
    end
end)



--calculate
local function toggleState(v)
    local state = v
    local transparency = state and 0.5 or 0
    local model = game:GetService("Workspace").Models.Field.Grass
    
    for _, part in pairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = not state
            part.Transparency = transparency
        end
    end
    
    if state then
        local part = Instance.new("Part")
        part.Size = Vector3.new(500, 0.001, 500)
        part.CFrame = CFrame.new(Vector3.new(10.3562937, -1.51527438, 30.4708614))
        part.Anchored = true
        part.Parent = game.Workspace
    
        local Anim = Instance.new("Animation")
        Anim.AnimationId = "rbxassetid://"
        local track = game:GetService("Players").LocalPlayer.Character.Humanoid:LoadAnimation(Anim)
        track:Play(.1, 1, 1)
    else
        if track ~= nil then
            track:Stop()
        end
    end
end


Tab5:NewToggle({
	Name = "Underground",
	default = false,
	callback = function(v)
        toggleState(v)
    end
})

local removeJumpCooldownConnection

Tab6:NewToggle({
	Name = "remove jump cooldown",
	default = false,
	callback = function(v)
        if v then
            removeJumpCooldownConnection = userInputService.JumpRequest:Connect(function()
                if v then
                    player.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
                end
            end)
        else
            if removeJumpCooldownConnection then
                removeJumpCooldownConnection:Disconnect()
            end
            
        end
    end,
})
--get

local infiniteJumpConnection

Tab5:NewToggle({
	Name = "inf jump",
	default = false,
	callback = function(v)
        if v then
            infiniteJumpConnection = userInputService.JumpRequest:Connect(function()
                if v then
                    player.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
                    player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end)
        else
            if infiniteJumpConnection then
                infiniteJumpConnection:Disconnect()
            end
            -- You can add additional logic here to reset the character's state if needed.
        end
    end,
})


